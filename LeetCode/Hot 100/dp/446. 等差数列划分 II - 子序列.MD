    //弱等差子序列--至少有两个元素的等差子序列
    //我们用一个二重循环去遍历nums 中的所有元素对(nums[i],nums[j])公差 d=nums[i]−nums[j]
    //dp[i]中存放nums[i]为结尾，差值为k的弱等差子序列的个数v
    
    public int numberOfArithmeticSlices(int[] nums) {
        int ans = 0;
        
        Map<Long,Integer>[] dp = new HashMap[nums.length];//dp[i] <k,v>表示以nums[i]结尾，差为k的弱等差数列有v个
        for (int i = 0; i <dp.length; i++) {
            dp[i] = new HashMap<>();
        }

        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                Long diff = (long) nums[i] -(long)nums[j];
                Integer cnt = dp[j].getOrDefault(diff, 0);  //所有以nums[j]为结尾，差值为diff的弱等差子序列加上nums[i]后长度至少为3，一定是符合题意的一个等差子序列
                ans+=cnt;
                dp[i].put(diff,dp[i].getOrDefault(diff,0)+cnt+1);// 以nums[i]结尾，差值为d的弱等差子序列的个数应该加上两部分:                
                                                                  //一部分以nums[j]为结尾，差值为d的弱等差子序列的个数;另一部分是nums[j], nums[i]这两个元素构成的弱等差子序列的个数
            }
        }
        
        return ans;
    }
