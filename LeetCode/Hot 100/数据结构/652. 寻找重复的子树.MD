    //方法1：思路是将root.val+dfs(left)+dfs(right)作为唯一标识存入map。
    //由于String长度有限，节点多了会报错。    
    Map<String,Integer> map = new HashMap<>();
    public int maxSubTree (TreeNode root) {
        if(root==null){
            return 0;
        }
        int cnt = 0;
        dfs(root);

        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            if(entry.getValue()>1){
                cnt = Math.max(cnt,getCnt(entry.getKey()));
            }
        }

        return cnt;
    }

    public String dfs(TreeNode root){
        if(root==null){
            return "0";
        }
        String left = dfs(root.left);		//String的长度为int最大值，越界
        String right = dfs(root.right);
        String ans = root.val+left+right;
        map.put(ans,map.getOrDefault(ans,0)+1); //直接将ans作为key
        return ans;
    }

    public int getCnt(String str){
        int cnt = 0;
        for (int i = 0; i < str.length(); i++) {
            if(str.charAt(i)=='1'){
                cnt++;
            }
        }
        return cnt;
    }
    
    
    //方法2，设置Map，将长String对应短uid，减小拼接的时间复杂度
    int t=1;                      //全局uid变量
    Map<String,Integer> trees;    //String-uid映射表"100"->1;"111"->2;"122"->3.....
    Map<Integer,Integer> counts;  //记录每一个uid的树形结构存在的个数
    List<TreeNode> ans;

    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        trees = new HashMap();
        counts = new HashMap();
        ans = new ArrayList();
        dfs(root);
        return ans;
    }

    public int dfs(TreeNode node){
        if(node == null){
            return 0;
        }
        String res = node.val +""+ dfs(node.left) +""+ dfs(node.right);
        int uid = trees.computeIfAbsent(res, x->t++);     //computeIfAbsent()==若存在key=res,则返回；否则返回t,并将res=t存入map中
        counts.put(uid,counts.getOrDefault(uid,0)+1);
        if(counts.get(uid)==2){
            ans.add(node);
        }
        return uid;
    }
